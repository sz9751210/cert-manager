import React, { useState, useEffect } from "react";
import {
  Alert,
  Switch,
  Select,
  Card,
  Drawer,
  Descriptions,
  Input,
  InputNumber,
  Form,
  Tabs,
  Layout,
  List,
  Menu,
  Modal,
  theme,
  Typography,
  Button,
  Space,
  message,
  Table,
  Tag,
  Tooltip,
  Timeline,
  FloatButton, // [å¯é¸] å¦‚æœæƒ³ç”¨æ‡¸æµ®æŒ‰éˆ•åˆ‡æ›
  ConfigProvider,
  Collapse,
} from "antd";
import {
  DashboardOutlined,
  DisconnectOutlined,
  SafetyCertificateOutlined,
  CloudSyncOutlined,
  ReloadOutlined,
  CheckCircleOutlined,
  WarningOutlined,
  CloudServerOutlined,
  StopOutlined,
  SettingOutlined,
  DownloadOutlined,
  ThunderboltOutlined,
  ClearOutlined,
  EyeInvisibleOutlined,
  EyeOutlined,
  InfoCircleOutlined,
  GlobalOutlined,
  BulbOutlined,
  BulbFilled,
} from "@ant-design/icons";
import {
  BrowserRouter,
  Routes,
  Route,
  Link,
  useLocation,
} from "react-router-dom";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import dayjs from "dayjs";
import relativeTime from "dayjs/plugin/relativeTime";
import "dayjs/locale/zh-tw";
import {
  fetchDomains,
  scanDomains,
  syncDomains,
  fetchZones,
  updateDomainSettings,
  testNotification,
  saveSettings,
  getSettings,
  fetchStats,
  batchUpdateSettings,
  batchScanDomains,
  scanSingleDomain,
} from "./services/api";
import DashboardCharts from "./components/DashboardCharts";
import type { SSLCertificate, DashboardStats, Notification } from "./types";
import type { ColumnsType } from "antd/es/table";
import Login from "./pages/Login"; // å¼•å…¥ç™»å…¥é 
import Settings from "./pages/Settings";
dayjs.extend(relativeTime);
dayjs.locale("zh-tw");

const { Header, Content, Sider } = Layout;
const { Title } = Typography;
const { TextArea } = Input;
const { Panel } = Collapse;
const { Text } = Typography;

// å®šç¾©æ‰€æœ‰é€šçŸ¥çš„é è¨­æ¨¡æ¿
const DEFAULT_TEMPLATES = {
  // 1. åˆ°æœŸ/ç•°å¸¸ (æœ€é‡è¦)
  expiry: `âš ï¸ [ç›£æ§å‘Šè­¦]
åŸŸå: {{.Domain}}
ç‹€æ…‹: {{.Status}}
å‰©é¤˜: {{.Days}} å¤©
åˆ°æœŸ: {{.ExpiryDate}}
IP: {{.IP}}`,

  // 2. æ–°å¢å­åŸŸå
  add: `ğŸŒ± [æ–°å¢ç›£æ§]
åŸŸå: {{.Domain}}
æ™‚é–“: {{.Time}}
å‚™è¨»: {{.Details}}`,

  // 3. åˆªé™¤å­åŸŸå
  delete: `ğŸ—‘ [ç§»é™¤ç›£æ§]
åŸŸå: {{.Domain}}
æ™‚é–“: {{.Time}}
å‚™è¨»: {{.Details}}`,

  // 4. çºŒç°½çµæœ
  renew: `â™»ï¸ [SSL çºŒç°½]
åŸŸå: {{.Domain}}
æ™‚é–“: {{.Time}}
çµæœ: {{.Details}}`,

  update: `ğŸ›  [DNS è®Šæ›´é€šçŸ¥]
åŸŸå: {{.Domain}}
æ™‚é–“: {{.Time}}
è®Šæ›´å…§å®¹: {{.Details}}`,

  sync_finish: `â˜ï¸ [Cloudflare åŒæ­¥å®Œæˆ]
æ–°å¢: {{.Added}} | æ›´æ–°: {{.Updated}}
åˆªé™¤: {{.Deleted}} | ç•¥é: {{.Skipped}}
è€—æ™‚: {{.Duration}}{{.Details}}`,

  scan_finish: `ğŸ” [SSL æƒæå®Œæˆ]
ç¸½æ•¸: {{.Total}}
æ­£å¸¸: {{.Active}}
éæœŸ: {{.Expired}}
ç•°å¸¸: {{.Warning}}
è€—æ™‚: {{.Duration}}`,
};


// --- å­çµ„ä»¶ï¼šåŸŸååˆ—è¡¨ (å¯é‡ç”¨) ---
const DomainListTable: React.FC<{
  ignoredFilter: string;
  showCharts?: boolean; // [æ–°å¢] æ§åˆ¶æ˜¯å¦é¡¯ç¤ºåœ–è¡¨
  isDarkMode?: boolean;
}> = ({ ignoredFilter, showCharts, isDarkMode }) => {
  const { token } = theme.useToken();
  const [selectedStatus, setSelectedStatus] = useState<string | undefined>(undefined);
  const [page, setPage] = useState(1);
  const [pageSize, setPageSize] = useState(10);
  const [onlyProxied, setOnlyProxied] = useState(false);
  const [selectedZone, setSelectedZone] = useState<string | null>(null);
  const [selectedRowKeys, setSelectedRowKeys] = useState<React.Key[]>([]); // [æ–°å¢] å­˜è¢«å‹¾é¸çš„ ID
  const [detailDrawerOpen, setDetailDrawerOpen] = useState(false);
  const [currentRecord, setCurrentRecord] = useState<SSLCertificate | null>(
    null
  );
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [editingDomain, setEditingDomain] = useState<SSLCertificate | null>(null);
  const [sortField, setSortField] = useState<string>("expiry_asc");
  const [editForm] = Form.useForm();
  const queryClient = useQueryClient();
  // [æ–°å¢] æ§åˆ¶è©³æƒ… Drawer çš„ state
  // 1. ç²å–ä¸»åŸŸååˆ—è¡¨ (ç”¨æ–¼ä¸‹æ‹‰é¸å–®)
  const { data: zones } = useQuery({
    queryKey: ["zones"],
    queryFn: fetchZones,
  });

  // æ ¹æ“šå‚³å…¥çš„ filterStatus å‘å¾Œç«¯è«‹æ±‚ä¸åŒè³‡æ–™
  const { data, isLoading, isFetching } = useQuery({
    queryKey: [
      "domains",
      page,
      pageSize,
      selectedStatus,
      onlyProxied,
      selectedZone,
      ignoredFilter,
      sortField,
    ],
    queryFn: () =>
      fetchDomains(
        page,
        pageSize,
        sortField,
        selectedStatus || "",
        onlyProxied ? "true" : "",
        ignoredFilter,
        selectedZone || ""
      ),
    refetchInterval: 10000,
    refetchOnWindowFocus: false, // [æ–°å¢] é—œé–‰è¦–çª—èšç„¦æ™‚çš„è‡ªå‹•åˆ·æ–°
    retry: 1,
  });

  // [æ–°å¢] è™•ç†è¡¨æ ¼æ’åºè®Šæ›´çš„å‡½å¼
  const handleTableChange = (pagination: any, filters: any, sorter: any) => {
    // 1. [é—œéµä¿®æ­£] å¦‚æœæ˜¯æ’åºè®Šæ›´ (sorter æœ‰å€¼)ï¼Œå¼·åˆ¶å›åˆ°ç¬¬ä¸€é 
    // é€™æ¨£ä½¿ç”¨è€…æ‰èƒ½çœ‹åˆ°æ’åºå¾Œã€Œæœ€ä¸Šé¢ã€çš„è³‡æ–™
    if (sorter.field && sorter.order) {
      setPage(1);
    }
    // å¦‚æœæœ‰é»æ“Šæ’åº (sorter.order å­˜åœ¨)
    // 2. è™•ç†æ’åºé‚è¼¯
    if (sorter.order) {
      let sortKey = "";

      switch (sorter.field) {
        // SSL åˆ°æœŸæ—¥ / å‰©é¤˜å¤©æ•¸
        case "days_remaining":
        case "not_after":
          sortKey = sorter.order === "ascend" ? "expiry_asc" : "expiry_desc";
          break;

        // ç¶²åŸŸè¨»å†Šåˆ°æœŸ
        case "domain_days_left":
        case "domain_expiry_date":
          sortKey = sorter.order === "ascend" ? "domain_expiry_asc" : "domain_expiry_desc";
          break;

        // ä¸Šæ¬¡æª¢æŸ¥æ™‚é–“
        case "last_check_time":
          sortKey = sorter.order === "ascend" ? "check_time_asc" : "check_time_desc";
          break;

        default:
          sortKey = "";
      }
      setSortField(sortKey);
    } else {
      // å¦‚æœä½¿ç”¨è€…å–æ¶ˆæ’åº (é»æ“Šç¬¬ä¸‰ä¸‹è®Šå›ç„¡æ’åºç‹€æ…‹)
      setSortField("");
    }
  };

  // æ›´æ–°è¨­å®šçš„ Mutation
  const updateSettingsMutation = useMutation({
    mutationFn: (values: { id: string; is_ignored: boolean; port: number }) =>
      // å‘¼å« API (é€™è£¡å‡è¨­æ‚¨çš„ api.ts æœ‰ updateDomainSettings ä¸”æ”¯æ´ port)
      updateDomainSettings(values.id, values.is_ignored, values.port),
    onSuccess: () => {
      message.success("è¨­å®šå·²æ›´æ–°ï¼Œä¸‹æ¬¡æƒæå°‡ç”Ÿæ•ˆ");
      setEditModalOpen(false);
      queryClient.invalidateQueries({ queryKey: ["domains"] });
    },
  });

  const handleEditClick = (record: SSLCertificate) => {
    setEditingDomain(record);
    editForm.setFieldsValue({
      port: record.port || 443, // é è¨­é¡¯ç¤º 443
    });
    setEditModalOpen(true);
  };
  // 2. [æ–°å¢] åˆ‡æ›å¿½ç•¥ç‹€æ…‹çš„ Mutation
  const toggleIgnoreMutation = useMutation({
    mutationFn: ({ id, val }: { id: string; val: boolean }) =>
      updateDomainSettings(id, val),
    onSuccess: () => {
      message.success("è¨­å®šå·²æ›´æ–°");
      queryClient.invalidateQueries({ queryKey: ["domains"] });
    },
    onError: () => message.error("æ›´æ–°å¤±æ•—"),
  });

  const { data: stats, isLoading: statsLoading } = useQuery({
    queryKey: ["stats"],
    queryFn: fetchStats,
    enabled: !!showCharts, // åªæœ‰ showCharts=true æ‰å»æŠ“
    refetchInterval: 60000,
    refetchOnWindowFocus: false, // [æ–°å¢] é—œé–‰èšç„¦åˆ·æ–°
    staleTime: 30000, // [æ–°å¢] 30ç§’å…§è¦–ç‚ºæ–°é®®è³‡æ–™ï¼Œä¸é‡è¤‡è«‹æ±‚
    retry: 1,
  });

  // [æ–°å¢] æ‰¹é‡æƒæ Mutation
  const batchScanMutation = useMutation({
    mutationFn: (ids: string[]) => batchScanDomains(ids),
    onSuccess: (response: any) => {
      // Axios response é€šå¸¸åœ¨ response.data ä¸­ï¼Œä½† api.ts å¯èƒ½å·²è™•ç†é
      const msg = response?.data?.message || response?.message || "æ‰¹é‡æƒæä»»å‹™å·²å•Ÿå‹•";
      message.success(msg);
      setSelectedRowKeys([]); // æ¸…ç©ºå‹¾é¸
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: ["domains"] });
      }, 2000);
    },
    onError: () => {
      message.error("æ‰¹é‡æƒæè«‹æ±‚å¤±æ•—");
    },
  });

  // æ‰¹é‡ Mutation
  const batchMutation = useMutation({
    mutationFn: ({ ids, val }: { ids: string[]; val: boolean }) =>
      batchUpdateSettings(ids, val),
    onSuccess: () => {
      message.success("æ‰¹é‡æ“ä½œæˆåŠŸ");
      setSelectedRowKeys([]); // æ¸…ç©ºå‹¾é¸
      queryClient.invalidateQueries({ queryKey: ["domains"] });
    },
  });

  // è™•ç†å‹¾é¸è®Šæ›´
  const onSelectChange = (newSelectedRowKeys: React.Key[]) => {
    setSelectedRowKeys(newSelectedRowKeys);
  };

  const rowSelection = {
    selectedRowKeys,
    onChange: onSelectChange,
  };

  const hasSelected = selectedRowKeys.length > 0;

  // è¼”åŠ©å‡½å¼ï¼šåˆ¤æ–·æ˜¯å¦çœ‹èµ·ä¾†åƒ IP (ç°¡å–®åˆ¤æ–·æ˜¯å¦åŒ…å«æ•¸å­—èˆ‡é»)
  const isIPAddress = (str: string) => {
    // ç°¡å–® Regexï¼šé–‹é ­æ˜¯æ•¸å­—
    return /^\d/.test(str);
  };

  // [æ–°å¢] å–®ä¸€åŸŸåæƒæ Mutation
  // æ³¨æ„ï¼šé€™éœ€è¦å¾Œç«¯æ”¯æ´ POST /api/v1/domains/:id/scan
  // å¦‚æœå¾Œç«¯é‚„æ²’å¯¦ä½œï¼Œé€™æœƒå ± 404
  const scanSingleMutation = useMutation({
    mutationFn: (id: string) => scanSingleDomain(id),
    onSuccess: () => {
      message.success("å·²è§¸ç™¼é‡æ–°æƒæï¼Œè«‹ç¨å¾Œåˆ·æ–°åˆ—è¡¨");
      // å»¶é²åˆ·æ–°ï¼Œè®“å¾Œç«¯æœ‰æ™‚é–“è™•ç†
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: ["domains"] });
      }, 1000);
    },
    onError: () => {
      message.error("æƒæè«‹æ±‚å¤±æ•— (è«‹æª¢æŸ¥å¾Œç«¯æ—¥èªŒ)");
    },
  });

  const columns: ColumnsType<SSLCertificate> = [
    {
      title: "ç‹€æ…‹",
      dataIndex: "status",
      width: 110,
      render: (status: string, record) => {
        if (record.is_ignored) return <Tag icon={<StopOutlined />}>å·²å¿½ç•¥</Tag>;
        let color = "default";
        let text = status;
        let icon = <CheckCircleOutlined />;

        if (status === "active") {
          color = "success";
          text = "æ­£å¸¸";
        }
        if (status === "warning") {
          color = "warning";
          text = "å³å°‡éæœŸ";
          icon = <WarningOutlined />;
        }
        if (status === "expired") {
          color = "error";
          text = "å·²éæœŸ";
          icon = <WarningOutlined />;
        }
        if (status === "unresolvable") {
          color = "red";
          text = "ç„¡æ³•è§£æ";
          icon = <DisconnectOutlined />;
        }
        if (status === "pending") {
          color = "processing";
          text = "ç­‰å¾…ä¸­";
          icon = <ReloadOutlined spin />;
        }

        return (
          <Tag icon={icon} color={color}>
            {text}
          </Tag>
        );
      },
    },
    {
      title: "åŸŸå",
      dataIndex: "domain_name",
      render: (text: string, record) => (
        <Space>
          <span
            style={{
              fontWeight: 600,
              color: record.is_ignored ? "#999" : "inherit",
            }}
          >
            {text}
          </span>
          {/* [æ–°å¢] æ†‘è­‰ä¸ç¬¦è­¦å‘Šåœ–ç¤º */}
          {!record.is_match && !record.is_ignored && record.status !== 'unresolvable' && (
            <Tooltip title={`å±éšªï¼šæ†‘è­‰éŒ¯èª¤ï¼(è©²æ†‘è­‰å¯¦éš›æ˜¯ç”¨æ–¼: ${record.sans?.[0] || 'å…¶ä»–ç¶²åŸŸ'})`}>
              <Tag color="red" icon={<StopOutlined />}>
                æ†‘è­‰éŒ¯ç½®
              </Tag>
            </Tooltip>
          )}
          {record.is_proxied && (
            <Tooltip title="Proxy ON">
              <CloudServerOutlined style={{ color: "#fa8c16" }} />
            </Tooltip>
          )}
        </Space>
      ),
    },
    // [æ–°å¢] æ†‘è­‰åŒ¹é…æ¬„ä½ (å»ºè­°æ”¾åœ¨ ç™¼è¡Œå•† ä¹‹å‰)
    {
      title: 'æ†‘è­‰åŒ¹é…',
      dataIndex: 'is_match',
      width: 100,
      render: (isMatch: boolean, record) => {
        if (record.is_ignored || record.status === 'unresolvable') return '-';

        if (isMatch) {
          return (
            <Tooltip title="æ†‘è­‰åç¨±èˆ‡åŸŸåç›¸ç¬¦">
              <Tag color="success" icon={<CheckCircleOutlined />}>Pass</Tag>
            </Tooltip>
          );
        } else {
          return (
            <Tooltip title={`å±éšªï¼šæ†‘è­‰éŒ¯èª¤ï¼é€šå¸¸æ˜¯å› ç‚ºé…ç½®äº†éŒ¯èª¤çš„æ†‘è­‰ã€‚`}>
              <Tag color="error" icon={<StopOutlined />}>Fail</Tag>
            </Tooltip>
          );
        }
      }
    },
    // [æ–°å¢] HTTP ç‹€æ…‹æ¬„ä½
    {
      title: "HTTP",
      dataIndex: "http_status_code",
      width: 80,
      render: (code: number, record) => {
        if (record.is_ignored) return <span style={{ color: "#ccc" }}>-</span>;

        // æ ¹æ“šç‹€æ…‹ç¢¼é¡¯ç¤ºä¸åŒé¡è‰²çš„ Tag
        if (!code || code === 0) {
          return <Tag color="red">Down</Tag>;
        }
        if (code >= 200 && code < 300) {
          return (
            <Tooltip title={`å›æ‡‰æ™‚é–“: ${record.latency}ms`}>
              <Tag color="success">{code}</Tag>
            </Tooltip>
          );
        }
        if (code >= 300 && code < 400) {
          return <Tag color="blue">{code}</Tag>; // Redirect
        }
        if (code >= 400 && code < 500) {
          return <Tag color="orange">{code}</Tag>; // 404 Not Found
        }
        if (code >= 500) {
          return <Tag color="error">{code}</Tag>; // 500 Server Error
        }
        return <Tag>{code}</Tag>;
      },
    },

    // [æ–°å¢] TLS ç‰ˆæœ¬æ¬„ä½
    {
      title: "TLS",
      dataIndex: "tls_version",
      width: 80,
      responsive: ["lg"], // å¯¬è¢å¹•æ‰é¡¯ç¤º
      render: (ver: string, record) => {
        if (record.is_ignored || !ver) return "-";

        // TLS 1.0/1.1 æ¨™ç¤ºç‚ºå±éšª
        let color = "cyan"; // é è¨­å®‰å…¨ (1.2, 1.3)
        if (ver === "TLS 1.0" || ver === "TLS 1.1") {
          color = "volcano";
        }
        if (ver === "Unknown") {
          color = "default";
        }

        return <Tag color={color}>{ver}</Tag>;
      },
    },
    {
      title: "å‰©é¤˜å¤©æ•¸",
      dataIndex: "days_remaining",
      width: 120,
      sorter: true,
      render: (days: number, record) => {
        if (record.is_ignored) return <span style={{ color: "#999" }}>-</span>; // å¿½ç•¥çš„ä¸é¡¯ç¤ºå¤©æ•¸
        if (record.status === "unresolvable" || record.status === "pending")
          return <span style={{ color: "#ccc" }}>-</span>;
        let color = "green";
        if (days < 30) color = "orange";
        if (days < 7) color = "red";
        return <span style={{ color, fontWeight: "bold" }}>{days} å¤©</span>;
      },
    },
    {
      title: "ç¶²åŸŸåˆ°æœŸ",
      dataIndex: "domain_days_left",
      width: 120,
      sorter: true,
      render: (days: number, record) => {
        if (record.is_ignored) return "-";
        // å¦‚æœ days ç‚º 0 æˆ–è² æ•¸ï¼Œå¯èƒ½æ˜¯æ²’æŸ¥åˆ°æˆ–è€…æ˜¯çœŸçš„éæœŸ
        // ç‚ºäº†å€åˆ† "æ²’æŸ¥åˆ°" (é€šå¸¸æ˜¯ 0) å’Œ "éæœŸ"ï¼Œå¯ä»¥æª¢æŸ¥ domain_expiry_date æ˜¯å¦ç‚ºç©º
        if (!record.domain_expiry_date)
          return <span style={{ color: "#ccc" }}>-</span>;

        let color = "default";
        if (days < 30) color = "red";
        else if (days < 60) color = "orange";
        else color = "green";

        return (
          <Tooltip
            title={`åˆ°æœŸæ—¥: ${dayjs(record.domain_expiry_date).format(
              "YYYY-MM-DD"
            )}`}
          >
            <Tag icon={<GlobalOutlined />} color={color}>
              {days} å¤©
            </Tag>
          </Tooltip>
        );
      },
    },
    {
      title: "ä¸Šæ¬¡æª¢æŸ¥", // [æ–°å¢]
      dataIndex: "last_check_time",
      width: 120,
      sorter: true,
      render: (date: string) => {
        // ä½¿ç”¨ YYYY-MM-DD æ ¼å¼ï¼Œä¸é¡¯ç¤ºå°æ™‚åˆ†é˜
        return date ? dayjs(date).format("YYYY-MM-DD") : "-";
      },
    },
    {
      title: "éæœŸæ—¥æœŸ",
      dataIndex: "not_after",
      width: 120,
      sorter: true,
      render: (date: string) => (date ? dayjs(date).format("YYYY-MM-DD") : "-"),
      responsive: ["md"],
    },
    {
      title: "éŒ¯èª¤è¨Šæ¯",
      dataIndex: "error_msg",
      width: 120, // [ä¿®æ”¹] çµ¦å®šå›ºå®šå¯¬åº¦
      render: (msg: string) => {
        if (!msg) return "-";
        return (
          // [æ–°å¢] Tooltip åŒ…è£¹
          <Tooltip title={msg} placement="topLeft">
            <div
              style={{
                width: "130px", // é…åˆ column width ç¨å¾®å°ä¸€é»
                whiteSpace: "nowrap", // ä¸æ›è¡Œ
                overflow: "hidden", // è¶…å‡ºéš±è—
                textOverflow: "ellipsis", // é¡¯ç¤ºçœç•¥è™Ÿ (...)
                color: "#ff4d4f", // ç´…è‰²æ–‡å­—
                cursor: "pointer", // æ»‘é¼ æ¸¸æ¨™è®Šæˆæ‰‹å‹
              }}
            >
              {msg}
            </div>
          </Tooltip>
        );
      },
      responsive: ["lg"],
    },
    // [æ–°å¢] æ“ä½œæ¬„ä½ï¼šæ˜¯å¦æª¢æŸ¥
    {
      title: "ç›£æ§ä¸­",
      dataIndex: "is_ignored",
      width: 80,
      render: (ignored: boolean, record) => (
        <Tooltip
          title={ignored ? "é»æ“Šé–‹å•Ÿç›£æ§" : "é»æ“Šå¿½ç•¥æª¢æŸ¥ (å…§ç¶²/æ¸¬è©¦åŸŸå)"}
        >
          <Switch
            checked={!ignored} // é€™è£¡é‚è¼¯åéä¾†ï¼šis_ignored=true ä»£è¡¨ checked=false (ä¸ç›£æ§)
            checkedChildren="é–‹å•Ÿ"
            unCheckedChildren="ç•¥é"
            onChange={(checked) => {
              toggleIgnoreMutation.mutate({ id: record.id, val: !checked });
            }}
            loading={toggleIgnoreMutation.isPending}
          />
        </Tooltip>
      ),
    },
    {
      title: "æ“ä½œ",
      key: "action",
      render: (_, record) => (
        <Space>
          {/* [æ–°å¢] ç·¨è¼¯æŒ‰éˆ• */}
          <Button
            size="small"
            icon={<SettingOutlined />}
            onClick={() => handleEditClick(record)}
          >
            è¨­å®š
          </Button>
          {/* [æ–°å¢] é‡æ–°æƒææŒ‰éˆ• */}
          <Tooltip title="ç«‹å³é‡æ–°æƒææ­¤åŸŸå">
            <Button
              size="small"
              icon={<ReloadOutlined />}
              loading={scanSingleMutation.isPending} // é€™è£¡é‚„æ²’è¾¦æ³•é‡å°å–®ä¸€ row loadingï¼Œæœƒä¸€èµ·è½‰ï¼Œå¦‚æœè¦å„ªåŒ–éœ€ç´€éŒ„ loadingId
              onClick={() => scanSingleMutation.mutate(record.id)}
            />
          </Tooltip>
          <Button
            type="text"
            icon={<InfoCircleOutlined />}
            onClick={() => {
              setCurrentRecord(record);
              setDetailDrawerOpen(true);
            }}
          >
            è©³æƒ…
          </Button>
        </Space>
      ),
    },
  ];

  return (
    <div>
      {" "}
      {/* åŒ…ä¸€å±¤ div */}
      {/* [æ–°å¢] é¡¯ç¤ºåœ–è¡¨ */}
      {showCharts && (
        <DashboardCharts
          stats={stats}
          loading={statsLoading}
          isDarkMode={isDarkMode}
        />
      )}
      <Card bordered={false} style={{ borderRadius: "8px" }}>
        <div
          style={{
            marginBottom: 16,
            display: "flex",
            gap: 16,
            alignItems: "center",
            padding: "12px",
            background: token.colorFillAlter,
            borderRadius: "4px",
          }}
        >
          {/* [æ–°å¢] ç‹€æ…‹ç¯©é¸å™¨ */}
          <div style={{ display: "flex", alignItems: "center" }}>
            <span style={{ marginRight: 8, fontWeight: 500 }}>ç‹€æ…‹:</span>
            <Select
              style={{ width: 140 }}
              placeholder="å…¨éƒ¨ç‹€æ…‹"
              allowClear
              value={selectedStatus}
              onChange={(val) => {
                setSelectedStatus(val);
                setPage(1); // åˆ‡æ›ç¯©é¸æ™‚å›åˆ°ç¬¬ä¸€é 
              }}
              options={[
                { label: 'ğŸŸ¢ æ­£å¸¸ (Active)', value: 'active' },
                { label: 'ğŸŸ  å³å°‡éæœŸ (Warning)', value: 'warning' },
                { label: 'ğŸ”´ å·²éæœŸ (Expired)', value: 'expired' },
                { label: 'ğŸš« ç„¡æ³•è§£æ (Error)', value: 'unresolvable' },
                { label: 'â³ ç­‰å¾…ä¸­ (Pending)', value: 'pending' },
                { label: 'âŒ æ†‘è­‰éŒ¯èª¤ (Mismatch)', value: 'mismatch' },
              ]}
            />
          </div>
          <div style={{ display: "flex", alignItems: "center" }}>
            <span style={{ marginRight: 8, fontWeight: 500 }}>ä¸»åŸŸå:</span>
            <Select
              style={{ width: 200 }}
              placeholder="é¸æ“‡ä¸»åŸŸå (All)"
              allowClear
              showSearch
              onChange={(value) => {
                setSelectedZone(value);
                setPage(1);
              }}
              options={zones?.map((z) => ({ label: z, value: z }))}
            />
          </div>
          <div
            style={{
              width: 1,
              height: 24,
              background: token.colorSplit,
              margin: "0 8px",
            }}
          ></div>
          <Space>
            <span>åªé¡¯ç¤º Proxy (æ©˜é›²):</span>
            <Switch checked={onlyProxied} onChange={setOnlyProxied} />
          </Space>
        </div>
        {/* [æ–°å¢] æ‰¹é‡æ“ä½œæç¤ºæ¢ */}
        {hasSelected && (
          <div
            style={{
              marginBottom: 16,
              padding: "8px 16px",
              background: token.colorInfoBg,
              border: `1px solid ${token.colorInfoBorder}`,
              borderRadius: 4,
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
            }}
          >
            <span>å·²é¸æ“‡ {selectedRowKeys.length} å€‹é …ç›®</span>
            <Space>
              {/* [æ–°å¢] æ‰¹é‡é‡æ–°æƒææŒ‰éˆ• */}
              <Button
                size="small"
                icon={<ThunderboltOutlined />}
                type="primary" // ç”¨ Primary é¡è‰²çªé¡¯é€™å€‹æ“ä½œ
                onClick={() => batchScanMutation.mutate(selectedRowKeys as string[])}
                loading={batchScanMutation.isPending}
              >
                æ‰¹é‡é‡æ–°æƒæ
              </Button>

              <Button
                size="small"
                icon={<EyeInvisibleOutlined />}
                onClick={() =>
                  batchMutation.mutate({
                    ids: selectedRowKeys as string[],
                    val: true,
                  })
                } // val: true ä»£è¡¨è¨­ç‚ºå¿½ç•¥
                loading={batchMutation.isPending}
              >
                æ‰¹é‡ç•¥é
              </Button>
              <Button
                size="small"
                icon={<EyeOutlined />}
                onClick={() =>
                  batchMutation.mutate({
                    ids: selectedRowKeys as string[],
                    val: false,
                  })
                } // val: false ä»£è¡¨é–‹å•Ÿç›£æ§
                loading={batchMutation.isPending}
              >
                æ‰¹é‡é–‹å•Ÿç›£æ§
              </Button>
              <Button
                size="small"
                type="text"
                onClick={() => setSelectedRowKeys([])}
              >
                å–æ¶ˆ
              </Button>
            </Space>
          </div>
        )}
        <Table
          rowSelection={rowSelection} // [æ–°å¢] é–‹å•Ÿå‹¾é¸åŠŸèƒ½
          columns={columns}
          dataSource={data?.data}
          rowKey="id"
          loading={isLoading}
          onChange={handleTableChange}
          pagination={{
            current: page,
            pageSize: pageSize,
            total: data?.total,
            onChange: (p, ps) => {
              setPage(p);
              setPageSize(ps);
            },
          }}
        />

        <Modal
          title={`ç·¨è¼¯è¨­å®š: ${editingDomain?.domain_name}`}
          open={editModalOpen}
          onCancel={() => setEditModalOpen(false)}
          onOk={() => {
            editForm.validateFields().then(values => {
              if (editingDomain) {
                updateSettingsMutation.mutate({
                  id: editingDomain.id,
                  port: values.port
                });
              }
            });
          }}
          confirmLoading={updateSettingsMutation.isPending}
        >
          <Form form={editForm} layout="vertical">
            <Form.Item label="æƒæ Port" name="port" tooltip="é è¨­ç‚º 443ï¼ŒMongoDB å¯è¨­ç‚º 27017">
              <InputNumber min={1} max={65535} style={{ width: '100%' }} />
            </Form.Item>
          </Form>
        </Modal>
        {/* ============================================================ */}
        {/* [æ–°å¢] è©³æƒ… Drawer */}
        <Drawer
          title="æ†‘è­‰è©³ç´°è³‡è¨Š"
          placement="right"
          width={500}
          onClose={() => setDetailDrawerOpen(false)}
          open={detailDrawerOpen}
        >
          {currentRecord && (
            <>
              <Descriptions title="åŸºæœ¬è³‡è¨Š" column={1} bordered size="small">
                <Descriptions.Item label="åŸŸå">
                  {currentRecord.domain_name}
                </Descriptions.Item>
                <Descriptions.Item label="DNS è§£æç´€éŒ„">
                  {currentRecord.resolved_record ? (
                    isIPAddress(currentRecord.resolved_record) ? (
                      // å¦‚æœæ˜¯ IPï¼Œç”¨ Tag é¡¯ç¤º (æ”¯æ´å¤š IP)
                      <Space wrap>
                        {currentRecord.resolved_record.split(', ').map(ip => (
                          <Tag key={ip} color="blue">{ip}</Tag>
                        ))}
                      </Space>
                    ) : (
                      // å¦‚æœæ˜¯ CNAMEï¼Œç”¨é€£çµåœ–ç¤º + æ–‡å­—
                      <Space>
                        <DisconnectOutlined rotate={90} style={{ color: '#fa8c16' }} />
                        <Text code copyable>{currentRecord.resolved_record}</Text>
                      </Space>
                    )
                  ) : (
                    <Text type="secondary">-</Text>
                  )}
                </Descriptions.Item>
                <Descriptions.Item label="ç™¼è¡Œå•†">
                  {currentRecord.issuer}
                </Descriptions.Item>
                <Descriptions.Item label="ç”Ÿæ•ˆæ—¥">
                  {dayjs(currentRecord.not_before).format("YYYY-MM-DD HH:mm")}
                </Descriptions.Item>
                <Descriptions.Item label="åˆ°æœŸæ—¥">
                  {dayjs(currentRecord.not_after).format("YYYY-MM-DD HH:mm")}
                </Descriptions.Item>
                <Descriptions.Item label="Cloudflare Proxy">
                  {currentRecord.is_proxied ? "é–‹å•Ÿ (PROXY)" : "é—œé–‰ (ç›´é€£)"}
                </Descriptions.Item>
                <Descriptions.Item label="Port">
                  {currentRecord.port ? currentRecord.port : 443}
                </Descriptions.Item>
              </Descriptions>

              <div style={{ marginTop: 24 }}>
                <h4>åŒ…å«çš„åŸŸå (SANs)</h4>
                <List
                  size="small"
                  bordered
                  dataSource={currentRecord.sans || []}
                  renderItem={(item) => <List.Item>{item}</List.Item>}
                  style={{ maxHeight: 300, overflowY: "auto" }}
                />
              </div>
            </>
          )}
        </Drawer>
      </Card>
    </div>
  );
};

// å®šç¾©å¯ç”¨è®Šæ•¸çš„èªªæ˜å…ƒä»¶
const VariableCheatSheet: React.FC = () => {
  const { token } = theme.useToken(); // ä½¿ç”¨ Hook ç²å–å‹•æ…‹é¡è‰²

  return (
    <div
      style={{
        marginTop: 8,
        padding: 8,
        // [ä¿®æ”¹] ä½¿ç”¨å‹•æ…‹ Tokenï¼Œè€Œéå¯«æ­» #f5f5f5
        background: token.colorFillAlter,
        borderRadius: token.borderRadius,
        // (é¸ç”¨) åŠ å€‹é‚Šæ¡†è®“å®ƒåœ¨æ·±è‰²æ¨¡å¼æ›´æ˜é¡¯
        border: `1px solid ${token.colorBorderSecondary}`,
      }}
    >
      <Text type="secondary" style={{ fontSize: 12 }}>
        å¯ç”¨è®Šæ•¸ (é»æ“Šè¤‡è£½):{" "}
      </Text>
      <div style={{ marginTop: 4, display: "flex", flexWrap: "wrap", gap: 4 }}>
        {[
          "{{.Domain}}",
          "{{.Days}}",
          "{{.ExpiryDate}}",
          "{{.Status}}",
          "{{.Issuer}}",
          "{{.IP}}",
          "{{.Record}}",
          "{{.TLS}}",
          "{{.HTTPCode}}",
        ].map((v) => (
          <Tag
            key={v}
            style={{ cursor: "pointer" }}
            onClick={() => {
              navigator.clipboard.writeText(v);
              message.success(`å·²è¤‡è£½è®Šæ•¸ ${v}`); // å»ºè­°åŠ ä¸Šå›é¥‹
            }}
          >
            {v}
          </Tag>
        ))}
      </div>
    </div>
  );
};

// è®Šæ•¸èªªæ˜å…ƒä»¶ (å…±ç”¨) - å·²ä¿®æ­£æš—é»‘æ¨¡å¼
const OpVariableCheatSheet: React.FC = () => {
  const { token } = theme.useToken(); // ä½¿ç”¨ Hook

  return (
    <div
      style={{
        margin: "8px 0",
        padding: 8,
        // [ä¿®æ”¹] ä½¿ç”¨å‹•æ…‹ Token
        background: token.colorFillAlter,
        borderRadius: token.borderRadius,
        border: `1px solid ${token.colorBorderSecondary}`,
      }}
    >
      <Text type="secondary" style={{ fontSize: 12 }}>
        å¯ç”¨è®Šæ•¸:{" "}
      </Text>
      <Space size={4} wrap>
        {["{{.Action}}", "{{.Domain}}", "{{.Details}}", "{{.Time}}"].map((v) => (
          <Tag
            key={v}
            style={{ cursor: "pointer" }}
            onClick={() => {
              navigator.clipboard.writeText(v);
              message.success(`å·²è¤‡è£½è®Šæ•¸ ${v}`);
            }}
          >
            {v}
          </Tag>
        ))}
      </Space>
    </div>
  );
};


// --- ä¸» Layout ---
const MainLayout: React.FC<{
  isDarkMode: boolean;
  toggleTheme: () => void;
}> = ({ isDarkMode, toggleTheme }) => {
  const {
    token: { colorBgContainer },
  } = theme.useToken();
  const location = useLocation();
  const queryClient = useQueryClient();
  const [settingsOpen, setSettingsOpen] = useState(false);
  // æ“ä½œæŒ‰éˆ•é‚è¼¯
  const syncMutation = useMutation({
    mutationFn: syncDomains,
    onSuccess: () => {
      message.success("åŒæ­¥è«‹æ±‚å·²ç™¼é€");
      queryClient.invalidateQueries({ queryKey: ["domains"] });
    },
    onError: () => message.error("åŒæ­¥å¤±æ•—"),
  });

  const scanMutation = useMutation({
    mutationFn: scanDomains,
    onSuccess: () => message.success("èƒŒæ™¯æƒæå·²å•Ÿå‹•"),
  });

  // å‹•æ…‹æ¨™é¡Œ
  let pageTitle = "ç›£æ§å„€è¡¨æ¿";
  if (location.pathname === "/unresolvable") pageTitle = "DNS è§£æç•°å¸¸åˆ—è¡¨";
  if (location.pathname === "/ignored") pageTitle = "å·²åœæ­¢ç›£æ§åˆ—è¡¨";

  return (
    <Layout style={{ minHeight: "100vh" }}>
      <Sider
        width={220}
        theme={isDarkMode ? "dark" : "dark"}
        style={{ background: isDarkMode ? "#001529" : "#001529" }}
      >
        <div
          style={{
            height: "64px",
            margin: "16px",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          }}
        >
          <SafetyCertificateOutlined
            style={{ fontSize: "24px", color: "#1890ff", marginRight: "8px" }}
          />
          <span
            style={{ color: "white", fontSize: "18px", fontWeight: "bold" }}
          >
            CertManager
          </span>
        </div>
        <Menu
          theme="dark"
          mode="inline"
          selectedKeys={[location.pathname]}
          items={[
            {
              key: "/",
              icon: <DashboardOutlined />,
              label: <Link to="/">ç›£æ§å„€è¡¨æ¿</Link>,
            },
            // [æ–°å¢] å´é‚Šæ¬„é¸é …
            {
              key: "/ignored",
              icon: <StopOutlined />,
              label: <Link to="/ignored">å·²åœæ­¢ç›£æ§</Link>,
            },
          ]}
        />
      </Sider>
      <Layout>
        <Header
          style={{
            padding: "0 24px",
            background: colorBgContainer,
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
          }}
        >
          <Title level={4} style={{ margin: 0 }}>
            {pageTitle}
          </Title>
          <Space>
            {/* [æ–°å¢] ä¸»é¡Œåˆ‡æ›æŒ‰éˆ• */}
            <Tooltip title="åˆ‡æ›æ·±è‰²/æ·ºè‰²æ¨¡å¼">
              <Button
                shape="circle"
                icon={isDarkMode ? <BulbFilled /> : <BulbOutlined />}
                onClick={toggleTheme}
              />
            </Tooltip>
            <Button
              icon={<SettingOutlined />}
              onClick={() => setSettingsOpen(true)}
            >
              è¨­å®š
            </Button>
            <Button
              icon={<CloudSyncOutlined />}
              onClick={() => syncMutation.mutate()}
              loading={syncMutation.isPending}
            >
              åŒæ­¥ CF
            </Button>
            <Button
              type="primary"
              icon={<ReloadOutlined />}
              onClick={() => scanMutation.mutate()}
              loading={scanMutation.isPending}
            >
              é‡æ–°æƒæ
            </Button>
          </Space>
        </Header>
        <Content style={{ margin: "24px 16px", padding: 24, minHeight: 280 }}>
          {/* ... Routes ... 
                       æ³¨æ„ï¼šæ‚¨å¯èƒ½éœ€è¦æŠŠ isDarkMode å‚³çµ¦ DomainListTable 
                       å¦‚æœè¦åœ¨è£¡é¢èª¿æ•´åœ–è¡¨é¡è‰²
                   */}
          <Routes>
            {/* 1. é¦–é ï¼šactive_only, ignored=false */}
            <Route
              path="/"
              element={
                <DomainListTable
                  ignoredFilter="false"
                  showCharts={true}
                  isDarkMode={isDarkMode}
                />
              }
            />

            {/* 3. [æ–°å¢] å·²å¿½ç•¥ï¼šä¸é™ç‹€æ…‹, ignored=true */}
            <Route
              path="/ignored"
              element={
                <DomainListTable
                  ignoredFilter="true"
                  showCharts={false}
                  isDarkMode={isDarkMode}
                />
              }
            />
          </Routes>
        </Content>
        <SettingsDrawer
          open={settingsOpen}
          onClose={() => setSettingsOpen(false)}
        />
      </Layout>
    </Layout>
  );
};

// ä¿è­·è·¯ç”±çµ„ä»¶
const ProtectedRoute: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const token = localStorage.getItem("token");
  if (!token) {
    // æ²’æœ‰ Tokenï¼Œé‡å®šå‘åˆ°ç™»å…¥é 
    // é€™è£¡ç”¨ window.location ç°¡å–®è™•ç†ï¼Œæˆ–æ˜¯ç”¨ Navigate çµ„ä»¶
    window.location.href = "/login";
    return null;
  }
  return <>{children}</>;
};

const App: React.FC = () => {
  // 1. åˆå§‹åŒ–ä¸»é¡Œç‹€æ…‹ (å„ªå…ˆå¾ localStorage è®€å–)
  const [isDarkMode, setIsDarkMode] = useState(() => {
    const saved = localStorage.getItem("theme");
    return saved === "dark";
  });

  // 2. åˆ‡æ›é‚è¼¯
  const toggleTheme = () => {
    const newMode = !isDarkMode;
    setIsDarkMode(newMode);
    localStorage.setItem("theme", newMode ? "dark" : "light");
  };

  // 3. å…¨åŸŸ Body èƒŒæ™¯è‰²æ§åˆ¶
  // ConfigProvider åªæ§åˆ¶ AntD å…ƒä»¶ï¼Œbody çš„èƒŒæ™¯è‰²éœ€è¦æ‰‹å‹•æ”¹ï¼Œä¸ç„¶æœƒæ˜¯ç™½çš„
  useEffect(() => {
    if (isDarkMode) {
      document.body.style.backgroundColor = "#000000"; // æˆ– #141414 (AntD Dark é è¨­)
      document.body.style.color = "#ffffff";
    } else {
      document.body.style.backgroundColor = "#f0f2f5";
      document.body.style.color = "#000000";
    }
  }, [isDarkMode]);

  return (
    <ConfigProvider
      theme={{
        // 4. ç¥å¥‡çš„ä¸€è¡Œç¨‹å¼ç¢¼ï¼šåˆ‡æ›æ¼”ç®—æ³•
        algorithm: isDarkMode ? theme.darkAlgorithm : theme.defaultAlgorithm,
        token: {
          // å¯ä»¥åœ¨é€™è£¡å¾®èª¿ä¸»è‰²èª¿
          colorPrimary: "#1890ff",
        },
      }}
    >
      <BrowserRouter>
        <Routes>
          <Route path="/login" element={<Login />} />
          <Route
            path="/*"
            element={
              <ProtectedRoute>
                <MainLayout isDarkMode={isDarkMode} toggleTheme={toggleTheme} />
              </ProtectedRoute>
            }
          />
        </Routes>
      </BrowserRouter>
    </ConfigProvider>
  );
};

export default App;
